// Allow negative indexing for last element
Array.prototype.__defineGetter__( -1, function() {
    return this.length > 0 && this[ this.length - 1 ] || undefined
} )

Array.prototype.__defineSetter__( -1, function( val ) {
    var idx = this.length > 0 ? this.length - 1 : 0
    this[ idx ] = val
} )

/*
if( load && ! mimis ) {
    console.log( load( 'load/js' ) )
}

var $ = $ !== undefined ? $ : mimis.load( '.../lib/jquery/types/jquery' )
*/

var $ = $ !== undefined ? $ :
    ( function() {
        var class2type = {}
        var classes = "Boolean Number String Function Array Date RegExp Object".split(" ")
        
        for( var i = 0; i < classes.length; i++ ) {
            var name = classes[ i ]
	    class2type[ "[object " + name + "]" ] = name.toLowerCase()
        }
        
        function type( obj ) {
	    return obj == null ?
		String( obj ) :
		class2type[ toString.call(obj) ] || "object";
	}
        
        var $ = {
	    isFunction : function( obj ) {
		return type( obj ) === 'function'
	    },
	    isArray : typeof Array.isArray != 'undefined' ? Array.isArray : function( obj ) {
		return type( obj ) === 'array'
	    },
            isString : function( str ) {
                return str instanceof String || type( str ) == 'string'
            },
            isObject : function( obj ) {
                return obj instanceof Object || $.type( obj ) == 'object'
            },
	    isPlainObject : function( obj ) {
              	if( ! obj || type( obj ) !== 'object' ) { // || obj.nodeType || $.isWindow( obj ) ) { // Important?
		    return false
		}

	        var hasOwn = Object.prototype.hasOwnProperty

		if( obj.constructor
                    && ! hasOwn.call( obj, 'constructor' )
                    && ! hasOwn.call( obj.constructor.prototype, 'isPrototypeOf' ) ) {
		    return false
		}

		var key
		for( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key )
            },
        }

        $.extend = function() {
	    var target = arguments[0] || {}
	    var deep = false
	    var i = 1

	    // Handle a deep copy situation
	    if( typeof target === 'boolean' ) {
		deep = target
		target = arguments[1] || {}
		// skip the boolean and the target
		i = 2
	    }
            
	    // Handle case when target is a string or something (possible in deep copy)
	    if( ! $.isObject( target ) && ! $.isFunction( target ) ) {
		target = {}
	    }
            
	    var length = arguments.length
            
	    // extend jQuery itself if only one argument is passed
	    if( length === i ) {
		target = this
		--i
	    }
            
	    var options, name, src, copy, copyIsArray, clone

	    for( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if( ( options = arguments[ i ] ) != null ) {
		    // Extend the base object
		    for( name in options ) {
			src = target[ name ]
			copy = options[ name ]
                        
			// Prevent never-ending loop
			if ( target === copy ) {
			    continue
			}
                        
			// Recurse if we're merging plain objects or arrays
			if( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
			    if ( copyIsArray ) {
				copyIsArray = false;
				clone = src && jQuery.isArray(src) ? src : [];
                                
			    } else {
				clone = src && jQuery.isPlainObject(src) ? src : {};
			    }
                            
			    // Never move original objects, clone them
			    target[ name ] = jQuery.extend( deep, clone, copy );
                            
			    // Don't bring in undefined values
			} else if ( copy !== undefined ) {
			    target[ name ] = copy;
			}
		    }
		}
	}

	// Return the modified object
	return target;
        }
    } )()

// Add array iterator
Array.prototype.each = typeof Array.prototype.each != 'undefined' ? Array.prototype.each :
    function each( f, args ) {
        if( $.isFunction( f ) ) {
            try {
                var out
                for( var i = 0; i < this.length; i++ ) {
                    var ret = f.apply( this[i], [ this[i], i, args ] )
                    if( ret === true || ret === false ) {
                        return ret
                    } else if( ret === undefined ) {
                    } else if( $.isArray( ret )
                               || ret.concatenable ) {
                        out = out || []
                        out = out.concat( ret )
                    } else if( $.isString( ret ) ) {
                        out = out || '' 
                        out = out.concat( ret )
                    } else if( $.isFunction( ret ) ) {
                        ret.call( this, out )
                    } else if( $.isObject( ret ) ) {
                        out = $.extend( true, ret, out )
                    }
                }
                return out
            } catch( e ) {
                console.debug( 'Ã¯:each: Exception In Loop: ', e )
                throw e
            }
        }
        return this
    }


String.prototype.concat = String.prototype.concat ||
    function() {
        var out = ''
        Array.prototype.each.apply( arguments, function() {
            out += this.toString()
        } )
        return out
    }

String.prototype.each = typeof String.prototype.each != 'undefined' ? String.prototype.each : Array.prototype.each

if( typeof NodeList != 'undefined' && NodeList.prototype != null ) {
    NodeList.prototype.each = NodeList.prototype.each || Array.prototype.each
}

if( typeof NamedNodeMap != 'undefined' && NamedNodeMap.prototype != null ) {
    NamedNodeMap.prototype.each = NamedNodeMap.prototype.each || function( f ) {
        Array.prototype.each.apply( this, [ function( attr, idx ) {
            f.apply( attr, [ attr.nodeValue, attr.name ] )
        } ] )
    }
}

/*
Array.prototype.__defineGetter__( 'empty', function() {
    return this.length == 0
} )
*/

/*
// Add array iterator
Array.prototype.each = Array.prototype.each || function each( f, args ) {
  if( typeof f == 'function' ) {
    for( var i = 0; i < this.length; i++ ) {
      ( function( item, args ) {
        f.apply( this, [ item, i, args ] )
      } ).apply(
        this,
        [ this[i], args ]
      )
    }
  }
}
*/
