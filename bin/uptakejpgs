#!/usr/bin/env python
<<<<<<< HEAD
# -*- coding: utf-8 -*-

"""
Pull jpeg images into mȉmis structure
"""

import logging
import os, re, sys, glob
import shutil
from PIL import Image
from PIL.ExifTags import TAGS
import getopt
=======

import logging
import os, re, glob
from PIL import Image
from PIL.ExifTags import TAGS
>>>>>>> eb9af66dde1fd709a85629532b0955f5e96b6a59

config = {
    'preface' : '.../by/time/',
    'maxpath' : '__/lib/uptake/max',
}

<<<<<<< HEAD
# ToDo: merge config with json.load( '.../lib/uptake/jpeg/json' )

logging.basicConfig( level = logging.INFO )
log = logging.getLogger(__name__)

try:
    optList, args = getopt.getopt( sys.argv[1:], 'q', [ 'dry-run', 'leave-orig' ] )
except getopt.GetoptError:
    log.info( __doc__.strip() )
    log.info( '  --dry-run: make no changes' )
    log.info( '  --leave-orig: maintain original filename' )
    sys.exit(2)

opts = {}
for opt, arg in optList:
    opts[ re.sub( r'^--', '', opt ) ] = arg

isDryRun = ( config.has_key( 'isDryRun' ) and config['isDryRun'] ) or opts.has_key( 'dry-run' )
leaveOrig = ( config.has_key( 'leaveOrig' ) and config['leaveOrig'] ) or opts.has_key( 'leave-orig' )

if not os.path.exists( '...' ):
    log.info( 'Connecting Relative Root: ...' )
    if not isDryRun: os.symlink( '../...', '...' )
=======
logging.basicConfig( level = logging.INFO )
log = logging.getLogger(__name__)

# ToDo: merge with json.load( '.../lib/uptake/jpeg/json' )

if not os.path.exists( "..." ):
    os.symlink( "../...", "..." )
>>>>>>> eb9af66dde1fd709a85629532b0955f5e96b6a59

max = 1
if os.path.exists( config['maxpath'] ):
    with open( config['maxpath'], 'w' ) as file:
        max = file.read()

<<<<<<< HEAD
timeKey = 'DateTimeOriginal'

for file in args:
=======
for file in glob.glob( "*" ):
    
    candidateFilter = re.compile( "^(.*).jpe?g$", re.IGNORECASE )
    match = candidateFilter.search( file )
    
    if match is None: continue

>>>>>>> eb9af66dde1fd709a85629532b0955f5e96b6a59
    img = Image.open( file )
    info = img._getexif()
    time = None
    for tag, value in info.items():
        decoded = TAGS.get( tag, tag )
<<<<<<< HEAD
        if decoded == timeKey:
            time = value
            break
        
    if time is None:
        log.debug( "Skipping: No '%s' in %s/exif" % ( timeKey, file ) )
        continue

    dir = config['preface'] + re.sub( r'[: ]', '/', time, 0 )
    try:
        if not isDryRun: os.makedirs( dir )
    except OSError as e:
        log.error( str(e) )

    dest = dir + '/jpg'
    
    log.info( 'Renaming: %s ➜ %s' % ( file, dest ) )
    if not isDryRun: shutil.move( file, dest )

    if leaveOrig:
        log.info( 'Maintaining Original: %s ↔ %s' % ( file, dest ) )
        if not isDryRun: os.symlink( dest, file )

    while os.path.lexists( str( max ) ):
        max = max + 1

    log.info( 'Linking: %s ↔ %s' % ( max, dir ) )
    if not isDryRun: os.symlink( dir, str( max ) )
=======
        if decoded == "DateTimeOriginal":
            time = value
            break
        
    if time is None: continue

    dir = config['preface'] + re.sub( r"[: ]", "/", time, 0 )
    try:
        os.makedirs( dir )
    except OSError as e:
        print str(e)

    dest = dir + "/jpg"
    
    log.info( "Renaming %s to %s" % ( file, dest ) )
    os.rename( file, dest )
    while os.path.lexists( str( max ) ):
        max = max + 1

    log.info( "Linking %s to %s" % ( max, dir ) )
    os.symlink( dir, str( max ) )

#     dir=".../by/time/$(exif -m "$file" | grep "^Date and Time (original)" | sed -e 's/.*\t//g' -e 's/[: ]/\//g')"
#     mkdir "$dir"
#     new="$dir/jpg"
#     mv "$file" "$new"
#     max=1
#     while [ -e "$max" ]; do
#         max=$(($max+1))
#     done
#     ln -s "$new" $max
# done
>>>>>>> eb9af66dde1fd709a85629532b0955f5e96b6a59
