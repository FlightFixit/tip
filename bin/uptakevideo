#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Pull video files into mȉmis structure
"""

import logging
import os, sys, re, glob
import shutil
import subprocess
import datetime, dateutil.parser
from datetime import datetime, timedelta
import getopt

config = {
    'preface' : '.../by/time/',
    'maxpath' : '__/lib/uptake/max',
}

logging.basicConfig( level = logging.INFO )
log = logging.getLogger(__name__)

try:
    optList, args = getopt.getopt( sys.argv[1:], "q", [ "dry-run" ])
except getopt.GetoptError:
    log.info( __doc__.strip() )
    log.info( '  --dry-run: make no changes' )
    sys.exit( 2 )

opts = {}
for opt, arg in optList:
    opts[ re.sub( r"^--", "", opt ) ] = arg

isDryRun = opts.has_key( "dry-run" )

# ToDo: merge with json.load( '.../lib/uptake/jpeg/json' )

if not os.path.exists( "..." ):
    log.info( "Connecting Relative Root: ..." )
    if not isDryRun: os.symlink( "../...", "..." )

max = 1
if os.path.exists( config['maxpath'] ):
    with open( config['maxpath'], 'w' ) as file:
        max = file.read()

for file in args:
    command = [ "ffprobe", "-show_format", file ]
    log.info( "Reading Metadata: %s" % ( " ".join( command ) ) )
    ffprobeOut = subprocess.Popen( command,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE ).stdout
    metadata = {
        "tag" : {}
    }
    for line in ffprobeOut.readlines():
        line = line.strip()
        if line == "[FORMAT]":
            continue
        if line == "[/FORMAT]":
            break
        ( key, val ) = line.split( "=", 1 )

        store = metadata
        if key.startswith( "TAG:" ):
            key = key.replace( "TAG:", "", 1 )
            store = store["tag"]

        if store.has_key( key ):
            raise Error( "Key Collision: " + key )

        store[key] = val

    ctime = (
        dateutil.parser.parse( metadata[ "tag" ][ "creation_time" ] )
        if metadata[ "tag" ].has_key( "creation_time" ) else
        datetime.fromtimestamp( os.path.getmtime( file ) ) )
    len = timedelta( seconds = float( metadata[ "duration" ] ) )
    
    dir = ( ctime.strftime( ".../by/date/%Y/%m/%d/@/%H/%M/%S/" ) +
            "+/%02d/%02d/%03d" % ( len.seconds / 60, len.seconds % 60, len.microseconds / 1000 ) )
        
    ffprobeOut.close()

    try:
        if not isDryRun: os.makedirs( dir )
    except OSError as e:
        log.error( str(e) )

    ( base, ext ) = os.path.splitext( file )
    ext = re.sub( r"^\.", "", ext, 0 ).lower()

    if ext == "mpg":
        ext = "mpeg"
    
    webmPath = dir + "/webm"
    if os.path.exists( webmPath ):
        log.info( "webm Exists: %s" % ( webmPath ) )
    else:
        webmFile = base + '.webm'
        if not os.path.exists( webmFile ):
            command = [ "towebm", file ]
            log.info( "Converting: %s" % ( " ".join( command ) ) )
            if not isDryRun: subprocess.call( command )
        if os.path.exists( webmFile ):
            log.info( "Placing webm: %s ➔ %s" % ( webmFile, webmPath ) )
            # if not isDryRun: os.rename( webmFile, webmPath )
            if not isDryRun: shutil.move( webmFile, webmPath )

    destPath = dir + "/" + ext
    if os.path.exists( destPath ):
        log.info( "Stub Exists for %s (%s)" % ( file, destPath ) )
    else:
        log.info( "Convert To Stub: %s ➔ %s" % ( file, destPath ) )
        if not isDryRun: shutil.move( file, destPath )

    while os.path.lexists( str( max ) ):
        max = max + 1

    log.info( "Linking %s to %s" % ( max, dir ) )
    if not isDryRun: os.symlink( dir, str( max ) )

    continue
