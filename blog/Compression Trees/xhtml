<!DOCTYPE html PUBLIC
 "+//ISBN 0-9673008-1-9//DTD OEB 1.0.1 Document//EN"
 "http://openebook.org/dtds/oeb-1.0.1/oebdoc101.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:t="tip:"
      xmlns:xi="http://www.w3.org/2001/XInclude">
<head profile="http://gmpg.org/xfn/11"> 
<link rel="icon" type="image/svg+xml" href=".../revolution/Technoanarchist/logo/letter/" />
<link rel="icon" type="image/png" href=".../revolution/Technoanarchist/logo/letter/png" />
<link rel="stylesheet" type="text/css" href=".../style/blog/css"/>
<link rel="stylesheet" type="text/css" href=".../lib/jquery/ui/css"/>
<link rel="stylesheet" type="text/css" href="css"/>
<title>Compression Trees</title>
</head>
<body>
<section>
<title>Compression Trees</title>

<style type="text/cssx"><![CDATA[
(* I'm going to write descriptors for tree decorators with the expectation that a team of programmers will adapt <is=.../lib/mimis/2. ̅0>Mìmís</> to apply these decorators. *)

/ > section > title[ text() == 'Abstract' ] {
}
]]></style>

<section>
<title>Abstract</title>

<p><a href=".../lib/mimis/">Mïmis</a> is a <acronym title="peer=to-peer">P2P</acronym> storage system. It intelligently combines contributions from all the nodes into the network into a navigable system. This is accomplished in part through an abstract representation of the local reseources as communicated to the network. This paper discusses the abstraction of the filesystem, specifically the efficient distributed invalidation of hash trees.</p>

</section>

<section>
<title>Mïmis URIs</title>

<ul>
<li>A Public Search: <a href=".../book/by/Nancy Kress/Sleepless/">.../book/Sleepless/by/Nancy Kress/</a></li>
<li>A <a href=".../blog/Compression Trees/">.../blog/Compression Trees/</a></li>
</ul>

</section>

<section id=".../lib/mimis/1/structure/">
<title>The Structure of Mïmis 1.0</title>

<object style="height: 300px" data=".../lib/mimis/1/structure/"/>

</section>

<section>
<title>Filesystem Tree</title>
<p>A java program running in an applet is monitoring the filesystem and mirroring its structure to a neo4j instance. A simple tree can be created with </p>

<object style="height: 300px" data="filesystem/traditional/svg"/>
</section>

<section>
<title>Hash Function</title>

<p>A hash function is a mathmatical operation that transforms a series of bits into a fixed-width hash code. So, for example, <acronym title="Simple Hashing Algorithm">sha</acronym>-256 can be performed on any file to produce a <em>likely unique</em> identifier.</p>

<p>While it is possible for two files with different bits to produce the same hash, the probability is vanishingly small. For example, the number of possible values representible by 256 bits is: 2<sup>256</sup> ≅ 1.1579209 × 10<sup>77</sup></p>

<p>For reference, <a href="http://www.madsci.org/posts/archives/may98/892502124.Ph.r.html">the net estimates there are 1.2 × 10<sup>57</sup> atoms in the solar system</a>.</p>
</section>

<section>
<title>Converting Filesystems to Hash Trees</title>

<ol>
<li>
<section>
<title>Hash Files</title>
<p>Take each file and rename it to its hash value:</p>

<object style="height: 300px" data="filesystem/hash/filenames/svg"/>
</section>
</li>
<li>
<section>
<title>Order By Hash Names</title>
<p>These filenames can now be ordered by their names:</p>

<object style="height: 300px" data="filesystem/hash/filenames/ordered/svg"/>
</section>
</li>
<li>
<section>
<title>Hash Collections</title>

<p>The ordered list of filenames is now hashed to produce a hash name for the directory:</p>

<object style="height: 300px" data="filesystem/hash/directories/svg"/>

<p><em>Note that it is not the contents of the files that is hashed, but the names. Using the actual bits of the files would also produce a unique hash identifier for the directory, but concatenating the names allows the actual bits to be removed.</em></p>
</section>
</li>
<li>
<section>
<title>Recurse</title>

<p>The process can be repeated to generate a hash for higher level directories:</p>

<object style="height: 300px" data="filesystem/hash/names/svg"/>
</section>
</li>
</ol>
</section>

<section>
<title>Implications</title>
<p>Drawn in a more conventional tree form, this structure would be:</p>

<object style="height: 300px" data="filesystem/hash/tree/svg"/>

<p></p>

<p>There are three main changes to the system:</p>
</section>

<section>
<title>Stub Names</title>

<p>Filenames are decomposed into directories containing files whose names are what were previously the file extensions. For example, consider the contents of my <a href=".../image/">image collection</a>. When I started I had files like:</p>

<ul>
  <li><a href=".../image/kitten/head/svg">kitten_head.svg</a></li>
  <li><a href=".../image/light bulb/svg">light bulb.svg</a></li>
  <li><a href=".../image/flag/England/">Flag of England.svg</a></li>
</ul>

<p>Converting them to stub form they become:</p>

<ul>
  <li><a href=".../image/kitten/head/svg">kitten/head/svg</a></li>
  <li><a href=".../image/light bulb/svg">light bulb/svg</a></li>
  <li><a href=".../image/flag/England/">flag/England/svg</a></li>
</ul>

<p>The directories leading up to the file are a list of increasingly specific tags. Part of the point of stub links is to ease comprehensible of alternate paths. For example, the path: <code><a href=".../book/by/Nancy Kress/Beggars in Spain/">book/by/Nancy Kress/Beggars in Spain/</a></code>.</p>

<ul>
  <li></li>
</ul>

<p>The directory <code>Beggars in Spain</code> is also linked to from:</p>

<ul>
  <li><a href=".../book/by/Nancy Kress/Beggars in Spain/">magazine/Asimov's Science Fiction/1991/April/Nancy Kress/Beggars in Spain</a></li>
  <li><a href=".../book/by/Nancy Kress/Beggars in Spain/">book/award/Hugo/winner/1992</a></li>
  <li><a href=".../book/by/Nancy Kress/Beggars in Spain/">book/award/Nebula/winner/1992</a></li>
  <li><a href=".../book/by/Nancy Kress/Beggars in Spain/">book/collection/The Year's Best Science Fiction/9th/Nancy Kress/Beggars in Spain</a></li>
  <li><a href=".../book/by/Nancy Kress/Beggars in Spain/">book/collection/The Year's Best Science Fiction/9th/1</a></li>
</ul>
</section>

<section>
<title>Relative Roots</title>

<p>Each directory contains a <code>...</code> subdirectory which is a symlink to <code>../...</code>. The one exception is the root of the filesystem where <code>...</code> is a link to <code>.</code>.</p>

<p>Structurally this creates a tree that looks like:</p>

<object id="fsdiagram" data=".../lib/mimis/tree/in/filesystem/svg"/>

<p></p>

</section>

<section>
<title>Indirected Binaries</title>

<p>At some depth of <a href=".../lib/bebnf/">parsing</a>, information can be thought of as <q>coherent</q>, meaning that there is an inter-relationship between the constituent parts ∋ removing a part will disrupt the gestalt.</p>

<p>For example, a <a href="http://stackoverflow.com/questions/1563883/decoding-a-jpeg-huffman-block-table">Huffman block</a> in a JPEG where changing any of the bits affects all of the decoded bits.</p>

<p>In the filesystem model, these are represented as files and stored as links to <code>.../hashes/</code></p>
</section>
</section>
</body>
</html>
