<?xml version="1.0" encoding="UTF-8"?>
<svg viewBox="-50 -50 100 100" width="100%" height="100%"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:tip=".../lib/tip/2010/05/05/"
     xmlns:html="http://www.w3.org/1999/xhtml"
     xmlns:smil="http://www.w3.org/ns/SMIL30"
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Hello World</title>
  <defs>
    <style type="text/css">
    </style>
    <script type="text/javascript" xlink:href=".../lib/tip/Array.each.js"/>
    <script type="text/javascript" xlink:href=".../lib/tip/List.js"/>
    <script type="text/javascript" xlink:href=".../lib/jquery/jquery.js"/>
    <script type="text/javascript" xlink:href=".../lib/tip/tip.jquery"/>

    <script type="text/javascript"><![CDATA[
        var win = ( function() {
            return {
                get width() { return window.innerWidth },
                get height() { return window.innerHeight },
            }
        } )()
        var view = ( function() {
            var attr = 'viewBox'
            var str = $.__.$('#').attr( attr ).split( ' ' )
            var viewbox = new List( {
                x : parseFloat( str[0] ),
                y : parseFloat( str[1] ),
                width : parseFloat( str[2] ),
                height : parseFloat( str[3] ),
            } )
            var view = { 
                get tx() {
                    return $.__.$('#').attr( attr, viewbox.__.join( ' ' ) )
                },
            }
            viewbox.__.each( function( val, prop ) {
                view.__defineGetter__( prop, function() {
                    return viewbox.__.get( prop )
                } )
                view.__defineSetter__( prop, function( val ) {
                    return viewbox.__.set( prop, val )
                } )
            } )
            return view
        } )()

        view.x = - win.width / 2
        view.y = - win.height / 2
        view.width = win.width
        view.height = win.height
        view.tx

        var scene = ( function() {
            var scene = []
            scene.capture = { frequency : { mHz : 100 } }

            var time = {
                get now() { return ( new Date() ).getTime() }
            }

            function once() {
                var now = time.now
                scene.begin = scene.begin || now
                
                if( scene.tixels === undefined ) {
                    scene.tixels = []
                    var state = {}
                    scene.each( function( animation ) {
                        animation.__.each( function walk( val, key ) {
                            switch( key ) {
                            case 'begin':
                                state.begin = now
                                break
                            case 'duration':
                                state.end = now + 1000
                                break
                            case 'animate':
                                val.each( function( animation ) {
                                    ( new List( animation ) ).__.each( walk )
                                } )
                                break
                            case 'to': case 'from':
                                state[ key ] = val
                                break
                            case 'attr':
                                val.each( function( attr ) {
                                    scene.tixels.push( {
                                        begin : state.begin,
                                        end : state.end,
                                        from : state.from,
                                        to : state.to,
                                        elem : state.elem,
                                        attr : attr,
                                    } )
                                    console.log( scene.tixels[-1].attr )
                                } )
                                break
                            }
                        } )
                    } )
                }
                
                scene.last = scene.last || scene.begin
                scene.tixels.each( function( tixel ) {
                    if( tixel.begin < now && tixel.end > scene.last ) {
                        tixel.elem[ tixel.attr ] =
                            tixel.from
                            + ( (tixel.to - tixel.from)
                                * (now - tixel.begin)
                                / (tixel.end - tixel.begin) )
                    }
                } )
                scene.last = now
            }

            var interval = { id : undefined }

            scene.__defineGetter__( 'once', once )
            scene.__defineGetter__( 'go', function() {
                if( interval.id === undefined ) {
                    interval.id =
                        setInterval( function() {
                            once.apply( scene, arguments )
                        },
                                   scene.capture.frequency.mHz )
                }
                return this
            } )
            scene.__defineGetter__( 'stop', function() {
                if( interval.id !== undefined ) {
                    clearInterval( interval.id )
                    interval.id = undefined
                }
                return this
            } )
            scene.__defineGetter__( 'running', function() {
                return interval.id !== undefined
            } )
            scene.__defineGetter__( 'pause', function() {
                if( this.running ) {
                    this.stop
                } else {
                    this.go
                }
                return this
            } )
            return scene
        } )()


        $( window ).bind( 'load', function() {
            $.__.$( 'tip:script' ).children().each( function traverse() {
                var $this = $( this )
                if( this.localName == 'animate' ) {
                    var parsers = {
                        json : function() {
                            return JSON.parse( $this.text() )
                        },
                        javascript : function() {
                            return eval( '(function() { return ' + $this.text().trim() + ' })()' )
                        },
                    }
                    var animation =
                        parsers[ $this.attr( 'type' ) ].apply( this )
                    if( animation ) {
                        var elems = {
                            rect : function() {
                                var $rect = $( this )
                                return {
                                    set x( x ) { $rect.attr( 'x', x ) },
                                    set y( y ) { $rect.attr( 'y', y ) },
                                    set width( width ) { $rect.attr( 'width', width ) },
                                    set height( height ) { $rect.attr( 'height', height ) },
                                }
                            },
                        }
                        var dest = this
                        while( dest.localName == 'animate' ) {
                            dest = dest.parentNode
                        }
                        // Since order matters for evaluation this needs to be earlier in the list
                        animation.__.set( 'elem', elems[ dest.localName ].apply( dest ) )
                        scene.push( new List( animation ) )
                    }
                } else {
                    $.__.$( '#' ).append( $this )
                }
                $this.children().each( traverse )
            } )
            scene.once
            scene.once
            scene.once
        } )
    ]]></script>
    <style type="text/css">
    </style>
  </defs>
  <tip:script>
    <rect id="box">
      <animate type="javascript">
    {
        begin : 0,
        duration : "1s",
        fill : "freeze",
        animate : [
            { 
                from : 0,
                to : -25,
                attr : [
                    "x",
                    "y"
                ],
            },
            {
                from : 0,
                to : 50,
                attr : [
                    "width",
                    "height"
                ],
            }
        ]
    }
    </animate>
    </rect>
  </tip:script>
</svg>
