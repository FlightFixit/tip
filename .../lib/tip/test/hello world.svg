<?xml version="1.0" encoding="UTF-8"?>
<svg viewBox="-50 -50 100 100" width="100%" height="100%"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:tip=".../lib/tip/2010/05/05/"
     xmlns:html="http://www.w3.org/1999/xhtml"
     xmlns:smil="http://www.w3.org/ns/SMIL30"
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Hello World</title>
  <defs>
    <style type="text/css">
    </style>
    <script type="text/javascript" xlink:href=".../lib/tip/Array.each.js"/>
    <script type="text/javascript" xlink:href=".../lib/tip/List.js"/>
    <script type="text/javascript" xlink:href=".../lib/jquery/jquery.js"/>
    <script type="text/javascript" xlink:href=".../lib/tip/tip.jquery"/>

    <script type="text/javascript"><![CDATA[
        var scene = ( function() {
            var scene = []
            scene.capture = { frequency : { mHz : 10 } }

            var time = {
                get now() { return ( new Date() ).getTime() }
            }

            function once() {
                var now = time.now
                scene.begin = scene.begin || now
                
                if( scene.tixels === undefined ) {
                    scene.tixels = []
                    var state = {}
                    scene.each( function( animation ) {
                        animation.__.each( function walk( val, key ) {
                            switch( key ) {
                            case 'begin':
                                state.begin = now
                                break
                            case 'duration':
                                state.end = now + 1000
                                break
                            case 'animate':
                                val.each( function( animation ) {
                                    ( new List( animation ) ).__.each( walk )
                                } )
                                break
                            case 'attr':
                                val.each( function( attr ) {
                                    scene.tixels.push( {
                                        begin : state.begin,
                                        end : state.end,
                                        from : state.from,
                                        to : state.to,
                                        elem : state.elem,
                                        attr : attr,
                                    } )
                                } )
                                break
                            default:
                                state[ key ] = val
                                break
                            }
                        } )
                    } )
                }

                var interpolators = {
                    number : function() {
                        return this.from
                            + ( (this.to - this.from)
                                * (now - this.begin)
                                / (this.end - this.begin) )
                    },
                }
                
                scene.last = scene.last || scene.begin
                scene.tixels.each( function( tixel ) {
                    if( tixel.begin < now && tixel.end > scene.last ) {
                        tixel.elem[ tixel.attr ] =
                            interpolators[ typeof tixel.from ].apply( tixel )
                    }
                } )
                scene.last = now
            }

            var interval = { id : undefined }

            scene.__defineGetter__( 'once', once )
            scene.__defineGetter__( 'go', function() {
                if( interval.id === undefined ) {
                    interval.id =
                        setInterval( function() {
                            once.apply( scene, arguments )
                        },
                                   scene.capture.frequency.mHz )
                }
                return this
            } )
            scene.__defineGetter__( 'stop', function() {
                if( interval.id !== undefined ) {
                    clearInterval( interval.id )
                    interval.id = undefined
                }
                return this
            } )
            scene.__defineGetter__( 'running', function() {
                return interval.id !== undefined
            } )
            scene.__defineGetter__( 'pause', function() {
                if( this.running ) {
                    this.stop
                } else {
                    this.go
                }
                return this
            } )
            return scene
        } )()

        $( window ).bind( 'load', function() {
            $.__.$( 'tip:script' ).children().each( function traverse() {
                var $this = $( this )
                if( this.localName == 'animate' ) {
                    var parsers = {
                        json : function() {
                            return JSON.parse( $this.text() )
                        },
                        javascript : function() {
                            return eval( '(function() { return ' + $this.text().trim() + ' })()' )
                        },
                    }
                    var animation =
                        parsers[ $this.attr( 'type' ) ].apply( this )
                    if( animation ) {
                        var elems = {
                            rect : function() {
                                var $rect = $( this )
                                var rect = {
                                    set x( x ) { $rect.attr( 'x', x ) },
                                    set y( y ) { $rect.attr( 'y', y ) },
                                    set width( width ) { $rect.attr( 'width', width ) },
                                    set height( height ) { $rect.attr( 'height', height ) },
                                }
                                rect.__defineSetter__( 'fill-opacity', function( val ) {
                                    $rect.css( 'fill-opacity', val )
                                } )
                                return rect
                            },
                        }
                        var dest = this
                        while( dest.localName == 'animate' ) {
                            dest = dest.parentNode
                        }
                        animation = new List( animation )
                        // Since order matters for evaluation this needs to be earlier in the list
                        animation.__.push( elems[ dest.localName ].apply( dest ), 'elem' )
                        scene.push( animation )
                    }
                } else {
                    $.__.$( '#' ).append( $this )
                }
                $this.children().each( traverse )
            } )
            scene.go
        } )
    ]]></script>
    <style type="text/css">
    </style>
  </defs>
  <tip:script>
    <sequence>
      <id>resize</id>
      <with>
        <var>
          <id>win</id>
          <ref>.../lib/tip/win.js</ref>
        </var>
        <var>
          <id>view</id>
          <ref>.../lib/tip/view.jquery</ref>
        </var>
        <do>
          <set><var>view.x</var><to>-win.width / 2</to></set>
          <set><var>view.y</var><to>-win.height / 2</to></set>
          <set><var>view.width</var><to>win.width</to></set>
          <set><var>view.height</var><to>win.height</to></set>
        </do>
      </with>
      <remove><id>resize</id></remove>
    </sequence>
    <rect>
      <as>box</as>
      <animate>
        <begin>0</begin>
        <duration>1s</duration>
        <animate>
          <from>0</from><to>-25</to>
          <attr>x</attr><attr>y</attr>
        </animate>
        <animate>
          <to>50</to>
          <attr>width</attr><attr>height</attr>
        </animate>
        <animate>
          <from>0</from><to>1</to>
          <attr>fill opacity</attr>
        </animate>
      </animate>
    </rect>
  </tip:script>
</svg>
