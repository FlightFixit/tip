
                                                                     
                                                                     
                                             


(defun solveList (mlist)
  (setf size (count-atoms mlist))
  (do ((left mlist (rest left)))
      ((equal left NIL) ) 
;    (print (car left))
;    (princ " - car left")
;    (print left)
;    (princ " - left")
;    (print mlist)
;    (princ " - mlist")
    (setf res (checkRemove (car left) mlist))
    (when (null res)			;This list resolved to an invalid state
      (return-from solveList NIL)
      )
    (unless (zerop (car res))		;something was eliminated, restart elimination search
;      (print 'resetsearch)
      (setf mlist (cdr res))
      (setf left (cons 0 mlist))
      )
;    (print res)
    (when (null (cdr left))		;Check for only existing possibility
					;(print left)
					;(princ 'noneleft)
;      (print 'trimsolo)
;      (print mlist)
      (setf res (trimSolo mlist))
;      (print res)
      (when (null res) (return-from solveList NIL))
      (unless (zerop (car res))
;	(print 'reset2)
	(setf mlist (cdr res))
	(setf left (cons 0 mlist))
	)
      )
    )
;  (print 'done)
  mlist
  )


(defun checkRemove (rem mlist)
					;(print 'check)
  (setf size (count-atoms mlist))
  (when (equal (length rem) 1)
    (setf nlist (removeSingle rem mlist))
    )
  (unless (equal (length rem) 1)
    (setf nlist (removeMult rem mlist))
    )
  
  (when (null nlist) (return-from checkRemove NIL))
  (when (NOT (equal size (count-atoms nlist))) (return-from checkRemove (cons (- size (count-atoms nlist)) nlist)))
  
					;(print 'something)
  (cons 0 mlist)
  )


       

(defun removeSingle (kill mlist)
					;(print 'rmsingle)
  (setf nlist NIL)
  (dolist (x mlist) 
    (setf nlist (cons (remove (car kill) x) nlist))
    )
  (setf nlist (reverse nlist))
  (setf nils 0)
  (setf mlist NIL)
  (dolist (x nlist)
    (when (null x) 
      (setf nils (+ nils 1))
      (setf mlist (cons  kill mlist))
      )
    (unless (null x)
      (setf mlist (cons x mlist))
      )
    )
  (if (> nils 1) NIL (reverse mlist))
  )

(defun removeMult (kill mlist)
					;(print 'rmmult)
  (setf nlist NIL)
  (setf n 0)
  (dolist (x mlist)
    (when (equal x kill) (setf n (+ n 1)))
    )
					;(print n)
					;(princ " - N")
					;(print (length kill))
					;(princ " - length kill")
  (when (equal n (length kill))		;can do solitary pairs, triples, etc
					;(print 'equal)
					;(setf nlist mlist)
    (dolist (x mlist)
					;(print x)
					;(princ " - x")
      (unless (equal kill x)
	(setf temp x)
	(dolist (y kill)
	  (setf temp (remove y temp))
	  )
	(setf nlist (cons temp nlist))
	)
      (when (equal kill x)
					;(print 'match)
	(setf nlist (cons x nlist))
					;(print nlist)
					;(princ " - nlist")
	)
      )
;    (print (reverse nlist))
;    (princ " - nlist")
					;check nlist valid
    (dolist (x nlist)
      (when (null x) (return-from removeMult NIL))
      )
    (return-from removeMult (reverse nlist))
    )
  (when (> n (length kill)) (return-from removeMult NIL)) ;This list is invalid
  mlist
  )



(defun count-atoms (lst)
  (cond
   ((null lst) 0)
   ((atom (car lst)) (+ 1 (count-atoms (cdr lst))))
   ((listp (car lst)) (+ (count-atoms (car lst)) (count-atoms (cdr lst))))
   )
  )


(defun trimSolo (mlist)
					; (print 'trimsolo)
					; (print mlist)
  (setf s (count-atoms mlist))
  (setf s1 s)
					;(setf nlist NIL)
  (do ((x 1 (+ x 1)))
      ((equal x 10))
					;   (print mlist)
    (setf n 0)
    (dolist (m mlist)
      (if (null (member x m)) NIL (setf n (+ n 1)))
      )
;    (print x)
;    (print n)
;    (princ " - N")
    (when (equal n 1)
      (setf nlist NIL)
      (dolist (m mlist)
	(if (null (member x m)) (setf nlist (cons m nlist)) (setf nlist (cons (list x) nlist)))
	)
      (when (NOT (equal s1 (count-atoms nlist)))
	(setf s1 (count-atoms nlist))
	(setf x 0)
	
	)
      (setf mlist (reverse nlist))
      )
    (when (zerop n)
      (return-from trimSolo NIL)
      )
;    (print nlist)
;    (princ " - nlist")
    
    )
					;(print 'exit)
  (cons (- s (count-atoms nlist)) (reverse nlist))
					;(cons (- s (count-atoms nlist)) nlist)
  )

(defun breakRows (puzzle)
;  (print 'breakrows)
  (setf lists NIL)
  (do ((x 1 (+ x 1)))
      ((equal x 10))
    (setf temp (list (pop puzzle) (pop puzzle) (pop puzzle) (pop puzzle) (pop puzzle) (pop puzzle) (pop puzzle) (pop puzzle) (pop puzzle)))
    (setf lists (cons temp lists))
    )
					;(breakColumns (reverse lists))
;  (print 'finishbreakrows)
  (reverse lists)
  )

(defun genList ()
  (setf li NIL)
					;(print 'test)
  (do ((x 1 (+ x 1)))
      ((equal x 82))
    (setf li (cons (list x) li))
    )
  (reverse li)
  )

(defun breakColumns (rows)
  
  (setf c1 NIL)
  (setf c2 NIL)
  (setf c3 NIL)
  (setf c4 NIL)
  (setf c5 NIL)
  (setf c6 NIL)
  (setf c7 NIL)
  (setf c8 NIL)
  (setf c9 NIL)

  (do ((x 1 (+ x 1)))
      ((equal x 10))
    (setf temp (pop rows))
    (setf c1 (cons (pop temp) c1))
    (setf c2 (cons (pop temp) c2))
    (setf c3 (cons (pop temp) c3))
    (setf c4 (cons (pop temp) c4))
    (setf c5 (cons (pop temp) c5))
    (setf c6 (cons (pop temp) c6))
    (setf c7 (cons (pop temp) c7))
    (setf c8 (cons (pop temp) c8))
    (setf c9 (cons (pop temp) c9))
    )

  (list (reverse c1) (reverse c2) (reverse c3) (reverse c4) (reverse c5) (reverse c6) (reverse c7) (reverse c8) (reverse c9) )

  )

(defun break9Blocks (columns)
  (setf c1 (pop columns))
  (setf c2 (pop columns))
  (setf c3 (pop columns))
  (setf c4 (pop columns))
  (setf c5 (pop columns))
  (setf c6 (pop columns))
  (setf c7 (pop columns))
  (setf c8 (pop columns))
  (setf c9 (pop columns))
  
  (setf b1 NIL)
  (setf b2 NIL)
  (setf b3 NIL)
  (setf b4 NIL)
  (setf b5 NIL)
  (setf b6 NIL)
  (setf b7 NIL)
  (setf b8 NIL)
  (setf b9 NIL)
  
  (setf b1 (list (pop c1) (pop c2) (pop c3) (pop c1) (pop c2) (pop c3) (pop c1) (pop c2) (pop c3)))
  (setf b4 (list (pop c1) (pop c2) (pop c3) (pop c1) (pop c2) (pop c3) (pop c1) (pop c2) (pop c3)))
  (setf b7 (list (pop c1) (pop c2) (pop c3) (pop c1) (pop c2) (pop c3) (pop c1) (pop c2) (pop c3)))
  
  (setf b2 (list (pop c4) (pop c5) (pop c6) (pop c4) (pop c5) (pop c6) (pop c4) (pop c5) (pop c6)))
  (setf b5 (list (pop c4) (pop c5) (pop c6) (pop c4) (pop c5) (pop c6) (pop c4) (pop c5) (pop c6)))
  (setf b8 (list (pop c4) (pop c5) (pop c6) (pop c4) (pop c5) (pop c6) (pop c4) (pop c5) (pop c6)))
  

  (setf b3 (list (pop c7) (pop c8) (pop c9) (pop c7) (pop c8) (pop c9) (pop c7) (pop c8) (pop c9)))
  (setf b6 (list (pop c7) (pop c8) (pop c9) (pop c7) (pop c8) (pop c9) (pop c7) (pop c8) (pop c9)))
  (setf b9 (list (pop c7) (pop c8) (pop c9) (pop c7) (pop c8) (pop c9) (pop c7) (pop c8) (pop c9)))

  (list b1 b2 b3 b4 b5 b6 b7 b8 b9)
  )

(defun makePuzzle (blocks)
  (setf b1 (pop blocks))
  (setf b2 (pop blocks))
  (setf b3 (pop blocks))
  (setf b4 (pop blocks))
  (setf b5 (pop blocks))
  (setf b6 (pop blocks))
  (setf b7 (pop blocks))
  (setf b8 (pop blocks))
  (setf b9 (pop blocks))
  
  (list (pop b1) (pop b1) (pop b1) (pop b2) (pop b2) (pop b2) (pop b3) (pop b3) (pop b3)
	(pop b1) (pop b1) (pop b1) (pop b2) (pop b2) (pop b2) (pop b3) (pop b3) (pop b3)
	(pop b1) (pop b1) (pop b1) (pop b2) (pop b2) (pop b2) (pop b3) (pop b3) (pop b3)
	(pop b4) (pop b4) (pop b4) (pop b5) (pop b5) (pop b5) (pop b6) (pop b6) (pop b6)
	(pop b4) (pop b4) (pop b4) (pop b5) (pop b5) (pop b5) (pop b6) (pop b6) (pop b6)
	(pop b4) (pop b4) (pop b4) (pop b5) (pop b5) (pop b5) (pop b6) (pop b6) (pop b6)
	(pop b7) (pop b7) (pop b7) (pop b8) (pop b8) (pop b8) (pop b9) (pop b9) (pop b9)
	(pop b7) (pop b7) (pop b7) (pop b8) (pop b8) (pop b8) (pop b9) (pop b9) (pop b9)
	(pop b7) (pop b7) (pop b7) (pop b8) (pop b8) (pop b8) (pop b9) (pop b9) (pop b9))
	

  )

(defun reducePuzzle (puzzle)
					;(setf puzzle (fillPuzzle puzzle))
  (setf psize (count-atoms puzzle))
  (setf npuzzle puzzle)
  (do ((answer nil))
      (NIL)
    
    (setf npuzzle (solve9Blocks(solveColumns(solveRows (breakRows npuzzle)))))
;    (print npuzzle)
;    (print psize)
;    (princ " - s")
;    (print (count-atoms npuzzle))
;    (princ " - ca")
;    (break)
    (when (equal (count-atoms npuzzle) psize)
      (return-from reducePuzzle npuzzle)
      )
    (setf psize (count-atoms npuzzle))
    )
  
  )

(defun solveRows (rows)
;  (print 'solverows)
					;(break)
					;(setf s (count-atoms rows))
  (setf nrows NIL)
  (dolist (r rows)
;    (print 'newrow)
    (setf nrows (cons (solveList r) nrows))
    )
  (setf nrows (reverse nrows))
					;(print s)
					;(princ " - s")
					;(print (count-atoms nrows))
					;(princ " - canrows")
					;(when (equal s (count-atoms nrows)) (return-from solveRows (breakColumns nrows)))
					;(break)
;  (print (makePuzzle (break9Blocks (breakColumns nrows))))
;  (break)
  (breakColumns nrows)
  
  
  )

(defun solveColumns (cols)
;  (print 'solvecolumns)
					;(break)
  (setf s (count-atoms cols))
  (setf ncols NIL)
  (dolist (r cols)
    (setf ncols (cons (solveList r) ncols))
    )
  (setf ncols (reverse ncols))
;  (print (makePuzzle (break9Blocks ncols)))
;  (break)
  (break9Blocks ncols)
  )

(defun solve9Blocks (blocks)
;  (print 'solveblocks)
					;(break)
  (setf s (count-atoms blocks))
  (setf nblocks NIL)
  (dolist (r blocks)
    (setf nblocks (cons (solveList r) nblocks))
    )
  (setf nblocks (reverse nblocks))
;  (print (makePuzzle nblocks))
;  (break)
  (makePuzzle nblocks)
  )

(defun fillPuzzle (puzzle)
;  (print 'fillpuzzle)
  (setf npuzzle NIL)
  (dolist (n puzzle)
;    (print n)
    (if (zerop n) (setf npuzzle (cons '(1 2 3 4 5 6 7 8 9) npuzzle)) (setf npuzzle (cons (list n) npuzzle)))
    )
;  (print 'finishfillpuzzle)
  (reverse npuzzle)
  )

(defun constrain (puzzle index value)
  (setf copypuz NIL)
  (do ((i 0 (+ i 1)))
      ((equal i 81))
    (if (equal i index) (progn (setf copypuz (cons (list value) copypuz)) (pop puzzle)) (setf copypuz (cons (pop puzzle) copypuz)))
    ) 
  (setf npuz (reducePuzzle (reverse copypuz)))
  (if (equal (car npuz) NIL) NIL npuz)
  )