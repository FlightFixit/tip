(dribble 'assignment_1.dribble)
(setq exp '(car (cdr (cdr '(a b x d)))))
(format t "~S = ~S~%" exp (eval exp))

(setq exp '(car (car (cdr (car (cdr '(a (b (x d)))))))))
(format t "~S = ~S~%" exp (eval exp))

(setq x '(a b c))
(setq exp '(append x x))
(format t "~S = ~S~%" exp (eval exp))

(defun replace-first (x y) (append (list x) (cdr y)))
(setq exp '(replace-first 'r x))
(format t "~S = ~S~%" exp (eval exp))

(defun power-of-two (n)
 (cond ((= n 0) 1)
       ((> n 0) (* 2 (power-of-two (1- n))))
       ((< n 0) (/ 1.0 (power-of-two (- n))))))

(defun print-power (n)
  (format t "2^~D = ~D~%" n (power-of-two n)))

(print-power 4)
(print-power -4)
(print-power 0)

(defun power-of-two (n)
 (do ((x 1 (+ x 1)) (sum 1))
     ((> x (abs n)) (cond ((< n 0) (/ 1.0 sum))
                           (t sum)))
     (setq sum (* 2 sum))))

(print-power 4)
(print-power -4)
(print-power 0)

(defun count-atoms (list)
 (let ((count 0))
      (cond ((listp list) (dolist (x list) (setq count (+ count (count-atoms x)))))
            (t (setq count 1)))
      count))

(defun print-count (list)
  (format t "(count-atoms ~S) = ~D~%" list (count-atoms list)))

(print-count '(a (b c) (d (e) f)))
(print-count 1)
(print-count nil)
(print-count '(()))
(print-count '(1 2 (3 nil) () 4 5 ((nil 9) 10 a) r))

(load 'map-bfs-dfs.lisp)

(defun depth-first-search (start-node goal-node)
  (let ((searched-nodes ()))
    (defun dfs-impl (current-node)
      (cond ((eq current-node goal-node) (list current-node))
            (t (setq searched-nodes (cons current-node searched-nodes))
               (let ((path nil))
                 (dolist (node (get current-node 'adjdst))
                   (cond ((not (member node searched-nodes))
                          (block recurse
                                 ;(format t "  Searching for ~S from ~S (~D)~%" goal-node current-node (length searched-nodes))
                                 (setq path (dfs-impl node))
                                 (if (not (eq path nil)) (return (cons current-node path)))))))))))
    (dfs-impl start-node)))
        
(defun print-path (start-city goal-city)
  (format t "Depth-First Route from ~S to ~S:~%" start-city goal-city)
  (let ((path (depth-first-search start-city goal-city)))
    (cond ((eq path nil) (format t " Not Found~%"))
          (t (format t " Found: ~S~%" path)))))

(print-path 'weathertop 'bree)
(print-path 'weathertop 'rivendell)
(print-path 'weathertop 'rivendale)

(defun breadth-first-search (start-node goal-node)
  (let ((searched-nodes ())
        (node-queue (list start-node)))
    (loop (when (or (endp node-queue) (eq goal-node (car node-queue))) (return))
          (let ((current-node (car node-queue))
                (children (get (car node-queue) 'adjdst)))
            (let ((new-children (set-difference children (append searched-nodes node-queue))))
              (dolist (node new-children) (setf (get node 'parent) current-node))
              (setq searched-nodes (append searched-nodes (list current-node)))
              (setq node-queue (append (cdr node-queue) new-children))
              ;(format t "  Searching for ~S from ~S (~D) ~S~%" goal-node current-node (length searched-nodes) node-queue)
              )))
    (defun getpath (node)
      (cond ((null node) nil)
            (t (append (getpath (get node 'parent)) (list node)))))
    (cond ((endp node-queue) nil)
          (t (getpath (car node-queue))))))
  
(defun print-path (start-city goal-city)
  (format t "Breadth-First Route from ~S to ~S:~%" start-city goal-city)
  (let ((path (breadth-first-search start-city goal-city)))
    (cond ((eq path nil) (format t " Not Found~%"))
          (t (format t " Found: ~S~%" path)))))

(print-path 'weathertop 'bree)
(print-path 'weathertop 'rivendell)
(print-path 'weathertop 'helms_deep)
(print-path 'weathertop 'rivendale)
(dribble)
